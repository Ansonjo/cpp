1.结构
在c++中使用结构、联合、枚举类型来定义变量时，不用再重复struct、 union、 enum关键字

结构成员可以是函数和类型
结构定义成员函数的方式
其中一个成员的类型   结构名::* p = &结构名::成员名




支持匿名联合

枚举类型不在等同于整数类型, 如果需要转化可以用强制类型转换,但是如果需要转化说明,你的设计不合理
enum Color* p;


c++增加了字符字面量,大小为1

void* 不能直接赋值给其他指针,可以强制类型转换

类型转换:
static_cast<类型>(数据):用于数值类型的转换,以及void*
reinterpret_cast<类型>数据
const_cast<T*>(T常量的地址)这样就可以修改T常量的值

函数
	潜规则:	1.默认返回int类型,作废
	                2.空参数表表示参数个数随意,c++中则表示无参.
	对于默认值,只在声明中写,定义就不用写了,默认值靠右


哑元    不指定形参名只给出类型  如show(int a,int),这是为了向下兼容

宏函数,c++基本不用
内联函数取而代之,用inline表示。内联函数会在调用的地方展开函数代码而不是产生调用，跟宏函数一样高效，但却有明确的参数类型而且没有副作用。是否真正执行inline的要求，未完全编译器自己决定
g++ -S



动态内存管理   堆内存
非数组: 	new 类型 (初始值)           delete 地址
数组:    new 类型[元素个数]     delete[] 地址
指定初始化值直接用一对空括号的称为零初始化
char * p = new char()   ; *p == '\0';


new 失败会throw抛出异常导致程序终止,可以new(nothrow)在申请内存失败时返回NULL,需要头文件<new>char * p = new char()   ; *p == '\0';

引用:本质上是指针, 编译器自动取地址、加星号

字符串: C 风格字符串数组长度问题, 忘记末尾的'\0'出乱码
			 C++风格字符串string类型,头文件string,同样支持像字符数组那样按下标访问元素,支持+,=,各种比较运算,不用考虑空间问题,成员函数size()length()都可以取得字符串长度.成员函数c_str可以返回c风格字符串(只读)
			 
数组: C风格的数组长度一旦确定,长度不变,作为参数传递就蜕变成地址无法知道长度只能再追加一个参数表示长度
c++风格数组用vector<类型>数组名(长度,元素初始值),,用法跟数组一样,随时可以用成员函数resize(长度)来取得元素个数.头文件<vector>





